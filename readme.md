# Stratégie de simulation pour un AGV autonome

**Introduction :** Les véhicules guidés automatisés (AGV) autonomes sont largement utilisés, par exemple dans les entrepôts industriels, pour le transport de marchandises. Avant de déployer un tel robot, une phase de **simulation** approfondie est essentielle afin de tester les algorithmes de contrôle et la fiabilité du système sans risque pour le matériel ou les opérateurs ([How to Simulate a Robot Using Gazebo and ROS 2](https://automaticaddison.com/how-to-simulate-a-robot-using-gazebo-and-ros-2/#:~:text=Roboticists%20like%20to%20simulate%20robots,high%20speed%20means%20lost%20money)). La simulation permet de reproduire un environnement réaliste (sol, obstacles, trajectoires) et d’anticiper le comportement du robot (stabilité, suivi de trajectoire, évitement d’obstacles) en ajustant les modèles et contrôleurs au préalable. Les sections suivantes présentent une stratégie complète de simulation d’un AGV autonome, depuis la **modélisation cinématique/dynamique** jusqu’à l’**intégration sous ROS 2** et la simulation dans **Gazebo** avec divers scénarios de test.

 ([How to Simulate a Robot Using Gazebo and ROS 2](https://automaticaddison.com/how-to-simulate-a-robot-using-gazebo-and-ros-2/)) *Exemple d’AGV industriel autonome en environnement d’entrepôt. La simulation logicielle permet de tester ce type de robot dans un environnement virtuel réaliste sans risques ni coûts liés à du matériel physique ([How to Simulate a Robot Using Gazebo and ROS 2](https://automaticaddison.com/how-to-simulate-a-robot-using-gazebo-and-ros-2/#:~:text=Roboticists%20like%20to%20simulate%20robots,high%20speed%20means%20lost%20money)).*

## 1. Modélisation cinématique et dynamique de l’AGV

**Modèle cinématique :** On considère un AGV à base roulante différentielle (deux roues motrices coaxiales et éventuellement une roue folle pour l’équilibre). Ce type d’architecture impose des *contraintes non holonomes* (pas de glissement latéral) qui lient les vitesses du robot. Les variables d’état typiques sont la position $(x, y)$ du châssis et son orientation $\theta$ (angle de lacet). Les commandes sont souvent les vitesses des roues gauche et droite (notées $\dot\phi_g$ et $\dot\phi_d$) ou équivalemment la vitesse linéaire vers l’avant $V$ et la vitesse de rotation angulaire $\omega$ du robot. La **cinématique directe** s’écrit généralement : 

- $V = \frac{R}{2}(\dot\phi_d + \dot\phi_g)$, la vitesse linéaire du châssis (avec $R$ le rayon des roues motrices) ([](https://depot-e.uqtr.ca/id/eprint/9076/1/032314468.pdf#:~:text=57)).
- $\omega = \frac{R}{L}(\dot\phi_d - \dot\phi_g)$, la vitesse angulaire de rotation (avec $L$ l’écartement entre les roues motrices). 

En conséquence, les **équations cinématiques** qui gouvernent le mouvement plan du robot sont : 

\[ \dot{x} = V \cos\theta, \qquad \dot{y} = V \sin\theta, \qquad \dot{\theta} = \omega ([](https://depot-e.uqtr.ca/id/eprint/9076/1/032314468.pdf#:~:text=57)). \]

Ces équations décrivent le mouvement du robot sur le sol en fonction de $V$ et $\omega$. L’AGV ne peut pas se déplacer latéralement (pas de $\dot{y}$ indépendante de $\dot{x}$), ce qui traduit la contrainte de non-dérapage. Pour d’autres configurations d’AGV, on pourrait adapter la cinématique (par ex. modèle tricycle ou à traction omnidirectionnelle), mais le modèle différentiel est le plus courant et pertinent pour de nombreux AGV industriels.

**Paramètres physiques typiques :** La table ci-dessous présente les paramètres physiques courants d’un petit AGV différentiel. Ces valeurs servent de base pour la simulation ; elles peuvent être ajustées en fonction d’un modèle réel spécifique :

| **Paramètre**                | **Symbole**        | **Valeur typique**                 | **Description**                          |
|------------------------------|--------------------|------------------------------------|------------------------------------------|
| Masse du châssis (sans charge)| $m$               | 50 kg (exemple)                    | Masse totale de la base mobile           |
| Rayon d’une roue motrice     | $R$                | 0,10 m                             | Rayon des roues motrices                 |
| Écartement entre roues       | $L$                | 0,50 m                             | Distance entre les deux roues motrices   |
| Moment d’inertie en lacet    | $I_z$             | $\sim 2$ kg·m² (selon répartition) | Inertie du robot en rotation (autour de $z$) |
| Coefficient de frottement au roulement | $f_r$ | 0,01–0,02 (adimensionnel)         | Frottement roulant effectif (sol/pneu)   |
| Couple moteur max par roue   | $\tau_{\max}$      | 5 N·m (exemple)                    | Capacité de couple des actionneurs       |
| Vitesse linéaire max         | $V_{\max}$         | 1,5 m/s                            | Vitesse de translation maximale          |
| Vitesse angulaire max        | $\omega_{\max}$    | 90 °/s (0,5π rad/s)                | Vitesse de rotation maximale             |

*Remarque :* Ces valeurs peuvent varier considérablement selon la taille et le type d’AGV. Par exemple, un petit robot mobile de recherche (~3,5 kg) aura des paramètres bien inférieurs à un AGV industriel pouvant transporter des charges de plus d’une tonne. Il est donc crucial d’ajuster ces paramètres pour qu’ils reflètent le système visé.

**Modèle dynamique (équations de Lagrange) :** Pour simuler de manière réaliste le comportement de l’AGV, il faut tenir compte de sa dynamique, c’est-à-dire la relation entre les forces/torques appliqués aux roues et le mouvement résultant (accélérations). La modélisation dynamique peut être obtenue via les **équations d’Euler-Lagrange**, en considérant le système comme un ensemble de solides rigides liés. 

- *Choix des coordonnées :* On peut utiliser les coordonnées généralisées $q = [x, y, \theta, \phi_g, \phi_d]$ (position du châssis et rotation des roues). Cependant, $x$ et $y$ ne sont pas indépendants à cause des contraintes non holonomes. Une approche courante consiste à utiliser un formalisme avec multiplicateurs de Lagrange pour inclure la contrainte de non-dérapage, ou à exprimer le modèle dans un sous-ensemble de coordonnées sans redondance (par ex. en utilisant $x, y, \theta$ pour la pose, et en traitant $\phi_g,\phi_d$ via la cinématique) ([Dynamic Modelling of Differential-Drive Mobile Robots using Lagrange and Newton-Euler Methodologies: A Unified Framework](https://www.hilarispublisher.com/open-access/dynamic-modelling-of-differentialdrive-mobile-robots-using-lagrange-and-newtoneuler-methodologies-a-unified-framework-2168-9695.1000107.pdf#:~:text=method%20for%20the%20formulation%20of,into%20account%20the%20non%02holonomic%20constraints)) ([Dynamic Modelling of Differential-Drive Mobile Robots using Lagrange and Newton-Euler Methodologies: A Unified Framework](https://www.hilarispublisher.com/open-access/dynamic-modelling-of-differentialdrive-mobile-robots-using-lagrange-and-newtoneuler-methodologies-a-unified-framework-2168-9695.1000107.pdf#:~:text=mobile%20robots%20%28DDMR%29,the%20modeling%20and%20design%20of)).

- *Lagrangien :* Le Lagrangien $L = T - V$ comprend l’énergie cinétique $T$ (translation du châssis, rotation du châssis, rotation des roues) et l’énergie potentielle $V$ (ici principalement la gravité, constante si le sol est plat, donc $V$ peut être pris nul en première approximation). Par exemple, pour un AGV différentiel : 
  - $T = \frac{1}{2} m (\dot{x}^2 + \dot{y}^2) + \frac{1}{2}I_z \dot{\theta}^2 + 2\left(\frac{1}{2}I_w \dot{\phi}^2\right)$, où $I_w$ est l’inertie d’une roue et $\dot{\phi}$ sa vitesse de rotation (supposées identiques gauche/droite pour simplifier).
  - $V \approx 0$ (châssis se déplaçant sur un plan horizontal).

- *Équations du mouvement :* En appliquant la méthode de Lagrange avec contraintes, on obtient les équations dynamiques couplant les accélérations et les torques moteurs. Sous forme vectorielle, on peut écrire un modèle réduit (dans le repère du robot) liant l’accélération linéaire $\dot{V}$ et angulaire $\dot{\omega}$ aux couples moteurs $τ_g, τ_d$ appliqués aux roues gauche et droite : 

\[ M(q)\,\ddot{q} + C(q,\dot{q})\,\dot{q} = B(q)\,\tau, \]

où $M$ est la matrice d’inertie équivalente du système, $C$ les termes de Coriolis/centrifuges et frottements, $B$ la matrice d’entrée reliant les torques des actionneurs aux coordonnées généralisées, et $\tau = [τ_g, τ_d]$ les couples moteurs ([Dynamic Modelling of Differential-Drive Mobile Robots using Lagrange and Newton-Euler Methodologies: A Unified Framework](https://www.hilarispublisher.com/open-access/dynamic-modelling-of-differentialdrive-mobile-robots-using-lagrange-and-newtoneuler-methodologies-a-unified-framework-2168-9695.1000107.pdf#:~:text=The%20dynamic%20equations%20are%20reduced,)). Dans le cas d’un robot différentiel, en négligeant les forces dissipatives complexes, ce modèle aboutit à des équations plus explicites. Par exemple, dans l’axe longitudinal du robot : 

- $(m + 2I_w/R^2)\,\dot{V} = \frac{τ_d + τ_g}{R} - F_{\text{roul}}$,  
- $(I_z + 2I_w (L/2R)^2)\,\dot{\omega} = \frac{τ_d - τ_g}{R} - M_{\text{friction}},$

où $F_{\text{roul}}$ représente les résistances au roulement totales, et $M_{\text{friction}}$ les frottements opposés à la rotation (par ex. frottements de pivotement). Ces formules traduisent : (i) l’accélération linéaire est proportionnelle à la somme des forces motrices sur les roues, et (ii) l’accélération angulaire est proportionnelle à la différence des forces entre roues gauche/droite. 

En l’absence de frottements, on obtient un modèle idéal : $m\dot{V} = (F_d+F_g)$ et $I_z \dot{\omega} = (F_d - F_g)\frac{L}{2}$, où $F_{d,g} = \frac{τ_{d,g}}{R}$ sont les forces développées par chaque roue. Ce modèle dynamique idéal correspond aux équations de Newton-Euler classiques du mouvement du châssis. **Cependant,** dans la réalité il faut inclure : l’inertie des roues $I_w$ (translatée par $R$), les frottements visqueux dans les moteurs et sur le sol, et la résistance au roulement. Ces éléments ajoutent des termes d’amortissement dans $C(q,\dot{q})$. 

En résumé, les équations dynamiques obtenues (souvent présentées sous forme simplifiée dans la littérature) permettent de simuler la réponse de l’AGV à des commandes de couple ou de vitesse de manière réaliste ([Dynamic Modelling of Differential-Drive Mobile Robots using Lagrange and Newton-Euler Methodologies: A Unified Framework](https://www.hilarispublisher.com/open-access/dynamic-modelling-of-differentialdrive-mobile-robots-using-lagrange-and-newtoneuler-methodologies-a-unified-framework-2168-9695.1000107.pdf#:~:text=the%20center%20of%20mass,61)). Elles serviront de base au modèle simulé sous MATLAB et Gazebo. 

## 2. Implémentation de la simulation sous MATLAB

Une fois le modèle mathématique établi, l’étape suivante consiste à l’**implémenter dans un environnement de simulation**. MATLAB est un choix approprié pour développer rapidement un simulateur grâce à ses solveurs d’équations différentielles et ses outils de visualisation.

**2.1 Choix du formalisme d’implémentation :** Deux approches sont possibles sous MATLAB : (a) utiliser un script MATLAB procédural couplant les équations du modèle à un solveur ODE numérique, ou (b) utiliser Simulink (avec éventuellement Simscape Multibody) pour construire un schéma bloc du modèle. Pour commencer simplement, on peut écrire les équations d’état sous la forme d’un système d’ODE de premier ordre. Par exemple, on définira un vecteur d’état $X = [x,\ y,\ \theta,\ V,\ \omega]$ (position, orientation et vitesses). Les équations de la section précédente donnent $\dot{X} = f(X, \tau_g, \tau_d)$, qu’on pourra coder dans une fonction MATLAB (par ex. `function dXdt = agv_dynamics(t, X, tau_g, tau_d)`).

**2.2 Solveur numérique :** MATLAB offre une gamme de solveurs ODE pour intégrer ce système. Le plus courant est le solveur explicite de Runge-Kutta d’ordre adaptatif **`ode45`**, approprié pour les systèmes non raides ([ODE45 | Solving ODEs in MATLAB - MATLAB](https://www.mathworks.com/videos/solving-odes-in-matlab-6-ode45-117537.html#:~:text=The%20most%20frequently%20used%20ODE,a%20companion%20order%20four%20method)). En effet, `ode45` est souvent le **choix par défaut** pour des équations de dynamique classiques, car il ajuste automatiquement le pas de temps pour équilibrer précision et performance. On utilisera donc `ode45` (ou un équivalent dans Simulink via un pas variable) pour intégrer les équations entre $t_0$ et $t_f$. Par exemple, un script MATLAB pourrait ressembler à : 

```matlab
% Définition des paramètres physiques
params.m = 50; params.R = 0.1; params.L = 0.5; ... % etc.

% Conditions initiales (position x0,y0, orientation theta0, vitesses nulles)
X0 = [0; 0; 0; 0; 0]; 

% Simulation sur 0 à 10s avec ode45
[t, X] = ode45(@(t,X) agv_dynamics(t,X, params, control_inputs(t)), [0 10], X0);
```

Ici `control_inputs(t)` représente une fonction définissant les **commandes de contrôle** au cours du temps (couples ou consignes de vitesse des roues). On peut par exemple implémenter un contrôle simple où $τ_g$ et $τ_d$ sont choisis pour faire avancer le robot en ligne droite ou pour suivre une courbe prédéfinie.

Si le modèle est **stiff** (raide) à cause de termes de forte dissipation ou de contacts intermittents, un solveur implicite du type `ode15s` pourrait être nécessaire ([Recommendations for Choosing a Solver (Control Design and ...](https://www.ni.com/docs/en-US/bundle/labview-control-design-and-simulation-module/page/lvsimconcepts/sim_c_ode.html?srsltid=AfmBOoqQiiU3JpVHhAtTW9uJBAG-VlFzBcrr9_wnHAyfjnmKjKycIRiW#:~:text=Recommendations%20for%20Choosing%20a%20Solver,solvers%20run%20deterministically%20on)). Néanmoins, pour un AGV avec dynamique douce, `ode45` suffit généralement. On veillera à fixer une tolérance adéquate (par ex. `RelTol = 1e-6`) pour assurer la précision sans pour autant allonger exagérément le temps de calcul.

**2.3 Analyse des résultats :** Une fois la simulation lancée, on obtient en sortie l’évolution des états du robot. Il est alors important d’analyser ces résultats pour vérifier que le comportement correspond aux attentes. Parmi les analyses typiques :

- **Vérification de la stabilité et du réalisme :** Par exemple, s’assurer que l’AGV ne dépasse pas ses accélérations maximales physiques, que l’orientation $\theta$ reste cohérente (pas de sauts brusques inexpliqués), etc. Si un comportement non physique apparaît, cela peut indiquer un bug dans le modèle ou le programme (par ex. un signe incorrect dans les équations).

- **Validation des lois de commande :** Si un contrôleur est inclus (par ex. un PID qui régule $V$ et $\omega$ pour suivre une trajectoire), on examinera l’erreur de suivi, les sur-oscillations, le temps de réponse, etc. On peut tracer l’erreur en fonction du temps pour évaluer la performance du contrôleur.

**2.4 Visualisation :** La visualisation claire des mouvements de l’AGV est cruciale pour interpréter la simulation. On pourra **tracer la trajectoire 2D** $(x(t), y(t))$ du robot pour visualiser son parcours dans le plan. Idéalement, on indique également l’orientation à intervalles réguliers (par exemple en dessinant une petite flèche ou un segment représentant le châssis à différentes positions sur la courbe). On pourra tracer sur une même figure la trajectoire cible et la trajectoire suivie par le robot afin de visualiser les écarts éventuels.

En complément, des graphiques en fonction du temps seront utiles : par exemple, $V(t)$ et $\omega(t)$ (vitesses linéaire et angulaire), ou encore les couples $τ_g(t), τ_d(t)$ envoyés. Ces courbes permettent de vérifier que les saturations ne sont pas dépassées et d’analyser la dynamique (accélérations, freinages). Dans MATLAB, on peut réaliser cela facilement via les fonctions de tracé (`plot`, etc.) sur les données `t` et `X` retournées par le solveur.

Enfin, pour une visualisation plus immersive, on pourrait utiliser Simulink 3D Animation ou exporter les données pour une animation. Néanmoins, dans le cadre de l’intégration ROS 2 et Gazebo (sections suivantes), on utilisera Gazebo pour la visualisation 3D réaliste. L’étape MATLAB sert surtout à valider le modèle mathématique et le contrôle dans un contexte simplifié.

## 3. Intégration des modèles et contrôleurs dans un nœud ROS 2

Une fois le modèle validé sous MATLAB, l’objectif est de l’intégrer dans un environnement **ROS 2** afin de profiter de l’écosystème robotique (communication entre nœuds, visualisation RViz, middleware temps-réel, etc.). Il s’agit de créer un ou plusieurs **nœuds ROS 2** qui incarnent le robot et son contrôleur.

**3.1 Architecture en nœuds :** Une architecture modulaire est recommandée. Par exemple, on peut séparer la simulation physique de l’AGV et les algorithmes de contrôle en deux nœuds distincts :
- **Nœud simulateur (modèle) :** Ce nœud implémente le modèle dynamique de l’AGV. À chaque itération (par ex. toutes les 10 ms), il met à jour l’état $(x, y, \theta, V, \omega)$ en intégrant les équations du mouvement, de façon similaire à ce qui a été fait sous MATLAB. En ROS 2, ce nœud pourrait être écrit en C++ ou Python en utilisant rclcpp/rclpy, et utiliser un timer pour appeler périodiquement une fonction d’intégration (par ex. un petit pas d’Euler ou de Runge-Kutta sur 10 ms). Il recevra en entrée des **commandes** (couples ou vitesses) via un topic ROS 2 (par ex. un topic `/cmd_vel` pour les consignes de $V$ et $\omega$). En sortie, il publiera l’**état** simulé du robot (par exemple sur le topic standard `/odom` de type *Odometry*, qui contient la pose et la vitesse estimées).

- **Nœud contrôleur :** Ce nœud contient la logique de contrôle haut-niveau de l’AGV. Par exemple, un contrôleur de suivi de trajectoire qui, à partir de la trajectoire désirée et de l’état courant (reçu depuis `/odom`), calcule les commandes à envoyer. Il publiera ces commandes sur `/cmd_vel` ou directement les torques sur un topic spécifique si on simule à ce niveau. On peut aussi imaginer plusieurs sous-nœuds : un pour la navigation globale (planification de trajectoire), un pour l’évitement d’obstacle local, etc., mais le tout s’inscrit dans l’architecture ROS 2 de manière standard.

Cette séparation permet une flexibilité : on peut à tout moment remplacer le nœud simulateur par le vrai robot (les topics `/cmd_vel` et `/odom` resteront les interfaces communes), ce qui est l’essence même de la robotique *sim2real*. 

**3.2 Intégration ROS 2 du modèle :** Pour implémenter concrètement le modèle dans un nœud, on peut s’appuyer sur la bibliothèque ROS 2 standard ou utiliser des outils comme **ROS2 Control**. Par exemple, ROS2 Control offre des *interfaces* pour créer un **hardware simulé**. On pourrait définir un plugin de type *DiffDriveController* couplé à un *SystemInterface* simulant la physique. Toutefois, pour garder cela plus pédagogique, on peut coder « manuellement » la propagation de l’état :
- Le nœud subscribe aux commandes de vitesse (twist) ou de couple.
- Il intègre l’équation cinématique si on ne simule qu’au niveau cinématique (plus simple, supposition que les consignes de vitesse sont suivies idéalement). Dans ce cas, $\dot{x},\dot{y},\dot{\theta}$ sont intégrées directement à chaque pas en utilisant $V$ et $\omega$ reçus (comme dans le modèle cinématique plus haut).
- Pour plus de fidélité, il intègre le modèle dynamique : il devra alors convertir les consignes (par ex. $V$ désiré) en torques requis, simuler l’inertie et le retard. Cela peut se faire avec un petit pas de calcul (par ex. un schéma d’Euler explicite à 1 kHz, suffisant pour la plupart des dynamiques d’AGV).

Pendant ce temps, le nœud publie en continu la nouvelle odométrie calculée. L’utilisation de ROS 2 garantit que ces données pourront être visualisées en direct (par RViz) et utilisées par d’autres composants (par ex. la navigation).

Notons qu’en ROS 2, l’**usage de simulateurs dédiés** (Gazebo, voir section suivante) est fréquent. Gazebo fournira son propre moteur physique, évitant de réécrire entièrement le modèle dans un nœud. Cependant, même avec Gazebo, on intègre via ROS 2 en utilisant des plugins (ex: plugin de commande de différentiel) qui font office du nœud simulateur. Dans tous les cas, la logique de contrôle (planification, décision) restera dans des nœuds ROS 2 séparés.

**3.3 Intégration des contrôleurs :** Le contrôleur de l’AGV peut être implémenté de plusieurs manières sous ROS 2 :
- Utiliser le **stack Nav2 (Navigation2)** si on vise à intégrer une navigation autonome complète (SLAM, planner global, planner local, contrôleur suivi de trajectoire, etc.). Nav2 fournit des nœuds configurables pour ces tâches, qu’on peut paramétrer pour notre robot. Par exemple, on peut configurer un contrôleur de type suivi de chemin (*Regulated Pure Pursuit Controller* ou autre) qui publiera des commandes `/cmd_vel` en fonction d’un but à atteindre.
- Écrire un contrôleur sur mesure : par exemple, un nœud Python qui implémente un asservissement simple (PID) sur l’erreur de trajectoire. Ce nœud souscrit à la pose actuelle (par `/odom` ou idéalement `/pose` filtrée) et éventuellement à un objectif (par ex. un topic `/goal_pose`). Il calcule l’erreur et sort une commande. L’algorithme peut être testé initialement dans MATLAB puis traduit en Python/C++.

L’intégration consiste à s’assurer que les **messages ROS 2** utilisés sont compatibles. Typiquement, on utilisera le message geometry_msgs/Twist pour les commandes de vitesse, et nav_msgs/Odometry pour l’état. Le nœud simulateur peut aussi publier des transformations TF (entre la base du robot et l’odométrie, etc.) pour que le reste de l’écosystème ROS 2 (par ex. RViz, Nav2) fonctionne correctement.

En somme, l’étape d’intégration ROS 2 consiste à recréer un **jumeau numérique** de l’AGV au sein d’une architecture distribuée. Une fois cela en place, on peut contrôler le robot en envoyant simplement des commandes de haut niveau, et observer la réponse dans l’environnement ROS 2 (RViz, logs). Avant d’aborder des scénarios complexes, on peut tester simplement en téléopérant le robot simulé (par exemple via un noeud de téléopération au joystick ou au clavier) pour vérifier que les commandes agissent correctement sur le modèle (le robot avance, recule, tourne comme attendu). 

## 4. Simulation dans Gazebo avec scénarios réalistes

Gazebo est un environnement de simulation 3D couplé à ROS 2 qui permet de simuler physiquement le robot dans un monde virtuel. Après avoir intégré le modèle dans ROS 2, on peut profiter de Gazebo pour tester des scénarios complets et visuels. L’AGV sera modélisé dans Gazebo via un fichier de description (URDF ou SDF) incluant ses dimensions, sa masse/inertie, et ses articulations (roues tournantes). Un plugin de contrôle (par ex. **gazebo_ros_diff_drive**) permettra d’appliquer des commandes de vitesse aux roues et simulera la dynamique de roulement de façon réaliste.

**4.1 Configuration de la simulation Gazebo :** On crée un modèle URDF de l’AGV en définissant des liens (le châssis, les deux roues motrices, éventuellement des roulettes passives) et des jonctions (fixe pour la roue folle, rotation pour les roues motrices). On renseigne les paramètres physiques du modèle (masse du châssis $m$, inertie $I_z$, inerties des roues, friction des roues sur le sol via les paramètres du contact Gazebo). Ensuite, via un plugin ROS 2, on connecte ce modèle aux interfaces de contrôle : par exemple, le plugin **gazebo_ros2_control** avec un contrôleur différentiel va exposer des topics `/cmd_vel` et va piloter le modèle dans Gazebo en conséquence. Ainsi, lorsqu’on lancera Gazebo, on pourra **contrôler le robot en envoyant des commandes de vitesse**, exactement comme avec le nœud simulateur manuel ([How to Simulate a Robot Using Gazebo and ROS 2](https://automaticaddison.com/how-to-simulate-a-robot-using-gazebo-and-ros-2/#:~:text=In%20this%20tutorial%2C%20we%20will,is%20what%20you%20will%20build)).

On prépare également l’**environnement** dans Gazebo : cela peut être un monde simple (sol plat, quelques obstacles cubiques) ou un environnement plus élaboré (par ex. maquette d’entrepôt avec étagères, murs, etc.). On peut utiliser des mondes existants ou créer un monde SDF customisé (tel que dans le tutoriel de création d’un entrepôt virtuel ([How to Simulate a Robot Using Gazebo and ROS 2](https://automaticaddison.com/how-to-simulate-a-robot-using-gazebo-and-ros-2/#:~:text=scratch%20using%20Gazebo,is%20what%20you%20will%20build))).

**4.2 Scénarios de test :** Une fois la simulation lancée (le robot apparaît dans Gazebo, prêt à recevoir des commandes), on peut dérouler plusieurs scénarios réalistes pour valider le système de contrôle :

- **Scénario 1 : Navigation libre (exploration aléatoire)** – Dans ce scénario, on teste la **réactivité de base du robot** sans trajectoire imposée. Par exemple, on peut programmer le robot pour avancer tout droit jusqu’à rencontrer un obstacle, puis tourner d’un angle aléatoire et continuer. L’AGV navigue ainsi de manière pseudo-aléatoire dans l’espace. Cela permet de vérifier la robustesse de l’évitement d’obstacles réactif (si des capteurs sont simulés, comme une LiDAR, on peut implémenter un algorithme du type *Braitenberg* ou *vrai-faux mur*). Si aucune intelligence n’est embarquée, ce scénario peut simplement consister à piloter l’AGV manuellement (téléopération) pour s’assurer qu’il répond correctement aux commandes de l’opérateur. **Critères d’observation :** le robot ne doit pas basculer, ni accélérer de façon non réaliste ; les capteurs doivent détecter les obstacles et le contrôleur réagir (ralentir, stopper ou dévier la trajectoire). On peut mesurer la distance minimale aux obstacles atteinte pour évaluer la sécurité.

- **Scénario 2 : Trajectoire prédéfinie (suivi de chemin)** – Ici, on évalue la capacité du contrôleur à faire suivre à l’AGV un trajet imposé, **sans obstacles dynamiques**. Par exemple, on définit un parcours en forme de boucle (carré, figure en huit, ou suite de points waypoints à atteindre séquentiellement). En amont, on peut calculer une trajectoire lisse (suite de poses $(x_{ref}(t), y_{ref}(t), \theta_{ref}(t))$ en fonction du temps) et utiliser un contrôleur de suivi (PID asservissant la position, ou contrôle en vitesse de type *pure pursuit*). On lance ce contrôleur dans ROS 2 : le robot dans Gazebo doit alors suivre la trajectoire. **Critères d’observation :** l’erreur de suivi (écart entre la position réelle et la position désirée) doit rester faible ; les oscillations ou dépassements de trajectoire doivent être contrôlés. On enregistre par exemple l’erreur maximale et finale. Ce scénario met en avant la performance du **système de contrôle en boucle fermée** dans un environnement idéal. Si Gazebo est configuré avec du bruit (par ex. bruit sur l’odométrie ou dérapage léger), on pourra aussi observer la robustesse aux incertitudes.

- **Scénario 3 : Évitement d’obstacles** – Ce scénario introduit des obstacles (statiques ou mobiles) sur le parcours du robot, testant ainsi la capacité de navigation autonome sûre. On peut, par exemple, demander à l’AGV d’aller d’un point A à un point B en **navigation libre** dans un environnement où des obstacles aléatoires (caisses, personnes simulées) sont présents. Pour ce faire, on intègre typiquement un module de planification locale : soit un algorithme de **navigation réactive** (par ex. évitement basé sur les vecteurs de champ potentiel, ou un simple PID sur la direction pour esquiver l’obstacle en fonction de la distance capteur), soit on s’appuie sur la pile Nav2 qui gère la planification globale et locale en utilisant les costmaps et plugins (Teb Local Planner, etc.). Durant la simulation, on surveille que le robot détecte bien l’obstacle (via son capteur simulé, ex: LiDAR dans Gazebo) et modifie sa trajectoire pour l’éviter tout en continuant vers sa destination. **Critères d’observation :** absence de collision (le **collision monitor** de Nav2 ou un script de surveillance peut confirmer que le robot n’entre pas en contact avec les obstacles) ; temps supplémentaire pris pour atteindre la cible (comparé à une trajectoire sans obstacle) ; comportement fluide ou saccadé lors de l’évitement. On peut également vérifier à l’aide de RViz que la cartographie et la localisation (si on utilise SLAM) fonctionnent correctement, et que le planificateur recalcule un chemin en temps réel lorsque de nouveaux obstacles apparaissent.

Pendant ces scénarios, Gazebo fournit un aperçu visuel précieux. On verra l’AGV évoluer dans l’environnement simulé, tandis que RViz peut afficher parallèlement l’estimation de position, la trajectoire prévue et les nuages de points capteurs ([Autonomous Navigation for a Mobile Robot Using ROS 2 Jazzy](https://automaticaddison.com/autonomous-navigation-for-a-mobile-robot-using-ros-2-jazzy/#:~:text=You%20should%20see%20Gazebo%20and,related%20visualizations)). Cette double visualisation (Gazebo pour la « réalité » simulée, RViz pour la perception côté robot) aide à diagnostiquer d’éventuels problèmes d’intégration capteur-contrôleur.

**4.3 Exploitation des résultats de simulation :** À l’issue des différents scénarios, on exploitera les **données enregistrées** (rosbags des topics /odom, /cmd_vel, /scan, etc.) pour quantifier les performances :
- Taux de réussite (par ex. % de trajectoires accomplies sans collision).
- Précision de suivi (erreur moyenne et max).
- Comportement du contrôleur (stabilité, temps de réponse aux imprévus).
- Charge CPU si on évalue l’implémentation en conditions temps réel (important pour s’assurer que l’algorithme peut tourner embarqué).

Ces informations permettront de raffiner le contrôleur ou le modèle si nécessaire. Par exemple, si l’on constate en simulation Gazebo que le robot glisse dans les virages (signe d’une mauvaise adhérence simulée), on pourra ajuster le coefficient de friction des roues dans le modèle. Si le suivi de trajectoire montre un dépassement, on ajustera les gains du contrôleur.

En conclusion, la stratégie de simulation complète comprend : une modélisation mathématique rigoureuse (cinématique et dynamique), une implémentation soignée sous MATLAB pour valider le modèle, une intégration modulaire sous ROS 2 des composants du robot, et enfin une série de tests dans Gazebo reproduisant des **situations réelles**. Cette démarche itérative assure que l’AGV autonome aura été éprouvé virtuellement dans de nombreuses conditions avant sa mise en service réelle, réduisant ainsi considérablement les risques et les coûts liés au développement ([How to Simulate a Robot Using Gazebo and ROS 2](https://automaticaddison.com/how-to-simulate-a-robot-using-gazebo-and-ros-2/#:~:text=Roboticists%20like%20to%20simulate%20robots,high%20speed%20means%20lost%20money)). Une telle simulation détaillée constitue donc un **outil indispensable** pour concevoir et valider un système de contrôle d’AGV autonome de manière efficace et sécurisée.

**Sources:** Les équations cinématiques et dynamiques utilisées proviennent de la littérature robotique mobile standard ([](https://depot-e.uqtr.ca/id/eprint/9076/1/032314468.pdf#:~:text=57)) ([Dynamic Modelling of Differential-Drive Mobile Robots using Lagrange and Newton-Euler Methodologies: A Unified Framework](https://www.hilarispublisher.com/open-access/dynamic-modelling-of-differentialdrive-mobile-robots-using-lagrange-and-newtoneuler-methodologies-a-unified-framework-2168-9695.1000107.pdf#:~:text=The%20dynamic%20equations%20are%20reduced,)). L’implémentation et le choix des solveurs s’appuient sur les recommandations MathWorks ([ODE45 | Solving ODEs in MATLAB - MATLAB](https://www.mathworks.com/videos/solving-odes-in-matlab-6-ode45-117537.html#:~:text=The%20most%20frequently%20used%20ODE,a%20companion%20order%20four%20method)). L’intégration ROS 2 et la simulation Gazebo suivent les bonnes pratiques des tutoriels ROS 2 officiels et de projets open-source ([How to Simulate a Robot Using Gazebo and ROS 2](https://automaticaddison.com/how-to-simulate-a-robot-using-gazebo-and-ros-2/#:~:text=In%20this%20tutorial%2C%20we%20will,is%20what%20you%20will%20build)) ([Autonomous Navigation for a Mobile Robot Using ROS 2 Jazzy](https://automaticaddison.com/autonomous-navigation-for-a-mobile-robot-using-ros-2-jazzy/#:~:text=You%20should%20see%20Gazebo%20and,related%20visualizations)). En combinant ces approches, on obtient une simulation fidèle pour le développement d’AGV autonomes.